delta2 = param_draws[1:10,3151:4057])
vote = house_votes_m[1:10,]
View(param_draws)
beta = param_draws[1:10,1:429]
alpha1 = param_draws[1:10,430:1336]
alpha2 = param_draws[1:10,1337:2243]
delta1 = param_draws[1:10,2244:3150]
delta2 = param_draws[1:10,3151:4057]
## old version (take too much time)
vpWAIC_old = function(vote,beta,alpha1,alpha2,delta1,delta2){
n_chain = nrow(beta)
prob = list()
product = matrix(nrow = nrow(vote), ncol = n_chain)
summation = matrix(nrow = nrow(vote), ncol = n_chain)
for (i in 1 : nrow(vote)){
for (chain in 1 : n_chain){
prob[[chain]] = vpProbability(vote,beta[chain,],alpha1[chain,],
alpha2[chain,],delta1[chain,],delta2[chain,])
product[i,chain] = prod((prob[[chain]][i,]^vote[i,])*((1-prob[[chain]][i,])^(1-vote[i,])), na.rm = TRUE)
summation[i,chain] = sum(vote[i,]*log(prob[[chain]][i,])
+(1-vote[i,])*(1-log(prob[[chain]][i,])), na.rm = TRUE)
}
}
WAIC = -2*sum(log(rowMeans(product)))-sum(apply(summation,1,var))
return(WAIC)
}
WAIC = vpWAIC_old(vote = house_votes_m[1:10,],
beta = param_draws[1:10,1:429],
alpha1 = param_draws[1:10,430:1336],
alpha2 = param_draws[1:10,1337:2243],
delta1 = param_draws[1:10,2244:3150],
delta2 = param_draws[1:10,3151:4057])
WAIC_old = vpWAIC_old(vote = house_votes_m[1:10,],
beta = param_draws[1:10,1:429],
alpha1 = param_draws[1:10,430:1336],
alpha2 = param_draws[1:10,1337:2243],
delta1 = param_draws[1:10,2244:3150],
delta2 = param_draws[1:10,3151:4057])
n_chain = nrow(beta)
prob = list()
product = matrix(nrow = nrow(vote), ncol = n_chain)
summation = matrix(nrow = nrow(vote), ncol = n_chain)
i = 1
for (chain in 1 : n_chain){
prob[[chain]] = vpProbability(vote,beta[chain,],alpha1[chain,],
alpha2[chain,],delta1[chain,],delta2[chain,])
product[i,chain] = prod((prob[[chain]][i,]^vote[i,])*((1-prob[[chain]][i,])^(1-vote[i,])), na.rm = TRUE)
summation[i,chain] = sum(vote[i,]*log(prob[[chain]][i,])
+(1-vote[i,])*(1-log(prob[[chain]][i,])), na.rm = TRUE)
}
View(product)
View(summation)
for (i in 1 : nrow(vote)){
for (chain in 1 : n_chain){
prob[[chain]] = vpProbability(vote,beta[chain,],alpha1[chain,],
alpha2[chain,],delta1[chain,],delta2[chain,])
product[i,chain] = prod((prob[[chain]][i,]^vote[i,])*((1-prob[[chain]][i,])^(1-vote[i,])), na.rm = TRUE)
summation[i,chain] = sum(vote[i,]*log(prob[[chain]][i,])
+(1-vote[i,])*(1-log(prob[[chain]][i,])), na.rm = TRUE)
}
}
View(vote)
vote = house_votes_m
n_chain = nrow(beta)
prob = list()
product = matrix(nrow = nrow(vote), ncol = n_chain)
summation = matrix(nrow = nrow(vote), ncol = n_chain)
i = 1
for (chain in 1 : n_chain){
prob[[chain]] = vpProbability(vote,beta[chain,],alpha1[chain,],
alpha2[chain,],delta1[chain,],delta2[chain,])
product[i,chain] = prod((prob[[chain]][i,]^vote[i,])*((1-prob[[chain]][i,])^(1-vote[i,])), na.rm = TRUE)
summation[i,chain] = sum(vote[i,]*log(prob[[chain]][i,])
+(1-vote[i,])*(1-log(prob[[chain]][i,])), na.rm = TRUE)
}
View(product)
i = 2
i = 4
View(prob)
prob[[1]]
(prob[[chain]][i,]^vote[i,])
(1-prob[[chain]][i,])^(1-vote[i,])
(prob[[chain]][i,]^vote[i,])*((1-prob[[chain]][i,])^(1-vote[i,])
)
prod((prob[[chain]][i,]^vote[i,])*((1-prob[[chain]][i,])^(1-vote[i,])), na.rm = TRUE)
for (i in 1 : nrow(vote)){
for (chain in 1 : n_chain){
prob[[chain]] = vpProbability(vote,beta[chain,],alpha1[chain,],
alpha2[chain,],delta1[chain,],delta2[chain,])
product[i,chain] = prod((prob[[chain]][i,]^vote[i,])*((1-prob[[chain]][i,])^(1-vote[i,])), na.rm = TRUE)
summation[i,chain] = sum(vote[i,]*log(prob[[chain]][i,])
+(1-vote[i,])*(1-log(prob[[chain]][i,])), na.rm = TRUE)
}
}
start_time <- Sys.time()
for (i in 1 : nrow(vote)){
for (chain in 1 : n_chain){
prob[[chain]] = vpProbability(vote,beta[chain,],alpha1[chain,],
alpha2[chain,],delta1[chain,],delta2[chain,])
product[i,chain] = prod((prob[[chain]][i,]^vote[i,])*((1-prob[[chain]][i,])^(1-vote[i,])), na.rm = TRUE)
summation[i,chain] = sum(vote[i,]*log(prob[[chain]][i,])
+(1-vote[i,])*(1-log(prob[[chain]][i,])), na.rm = TRUE)
}
}
nrow(vote)
vote = house_votes_m[1:10,]
start_time <- Sys.time()
for (i in 1 : nrow(vote)){
for (chain in 1 : n_chain){
prob[[chain]] = vpProbability(vote,beta[chain,],alpha1[chain,],
alpha2[chain,],delta1[chain,],delta2[chain,])
product[i,chain] = prod((prob[[chain]][i,]^vote[i,])*((1-prob[[chain]][i,])^(1-vote[i,])), na.rm = TRUE)
summation[i,chain] = sum(vote[i,]*log(prob[[chain]][i,])
+(1-vote[i,])*(1-log(prob[[chain]][i,])), na.rm = TRUE)
}
}
end_time <- Sys.time()
duration_old <- end_time - start_time
View(product)
View(summation)
end_time - start_time
duration_old <- end_time - start_time
duration_old
rowMeans(product)
(prob[[chain]][i,]^vote[i,])*((1-prob[[chain]][i,])^(1-vote[i,])
)
a = (prob[[chain]][i,]^vote[i,])*((1-prob[[chain]][i,])^(1-vote[i,]))
prod(a)
prod(a, na.rm = TRUE)
n_chain = nrow(beta)
prob = list()
product = matrix(nrow = n_chain, ncol = ncol(vote))
summation = matrix(nrow = nrow(vote), ncol = n_chain)
l = numeric(nrow(vote))
start_time <- Sys.time()
for (i in 1 : nrow(vote)){
for (chain in 1 : n_chain){
prob[[chain]] = vpProbability(vote,beta[chain,],alpha1[chain,],
alpha2[chain,],delta1[chain,],delta2[chain,])
product[chain,] = (prob[[chain]][i,]^vote[i,])*((1-prob[[chain]][i,])^(1-vote[i,]))
summation[i,chain] = sum(vote[i,]*log(prob[[chain]][i,])
+(1-vote[i,])*(1-log(prob[[chain]][i,])), na.rm = TRUE)
}
l[i]=sum(log(colMeans(product, na.rm = TRUE)))
}
end_time <- Sys.time()
duration_old <- end_time - start_time
colMeans(product, na.rm = TRUE)
log(colMeans(product, na.rm = TRUE))
sum(log(colMeans(product, na.rm = TRUE)),na.rm = TRUE)
for (i in 1 : nrow(vote)){
for (chain in 1 : n_chain){
prob[[chain]] = vpProbability(vote,beta[chain,],alpha1[chain,],
alpha2[chain,],delta1[chain,],delta2[chain,])
product[chain,] = (prob[[chain]][i,]^vote[i,])*((1-prob[[chain]][i,])^(1-vote[i,]))
summation[i,chain] = sum(vote[i,]*log(prob[[chain]][i,])
+(1-vote[i,])*(1-log(prob[[chain]][i,])), na.rm = TRUE)
}
l[i]=sum(log(colMeans(product, na.rm = TRUE)),na.rm = TRUE)
}
WAIC = -2*sum(l)-sum(apply(summation,1,var))
WAIC = -2*(sum(l)-sum(apply(summation,1,var)))
n_chain = nrow(beta)
prob = list()
product = matrix(nrow = n_chain, ncol = ncol(vote))
summation = matrix(nrow = nrow(vote), ncol = n_chain)
l = numeric(nrow(vote))
start_time <- Sys.time()
for (i in 1 : nrow(vote)){
for (chain in 1 : n_chain){
prob[[chain]] = vpProbability(vote,beta[chain,],alpha1[chain,],
alpha2[chain,],delta1[chain,],delta2[chain,])
product[chain,] = (prob[[chain]][i,]^vote[i,])*((1-prob[[chain]][i,])^(1-vote[i,]))
summation[i,chain] = sum(vote[i,]*log(prob[[chain]][i,])
+(1-vote[i,])*(1-log(prob[[chain]][i,])), na.rm = TRUE)
}
l[i]=sum(log(colMeans(product, na.rm = TRUE)),na.rm = TRUE)
}
end_time <- Sys.time()
duration_old <- end_time - start_time
WAIC = -2*(sum(l)-sum(apply(summation,1,var)))
WAIC = -2*sum(l)-sum(apply(summation,1,var))
WAIC = -2*(sum(l)-sum(apply(summation,1,var)))
n_chain <- nrow(beta)
prob <- list()
product <- matrix(nrow = n_chain, ncol = ncol(vote))
summation <- matrix(nrow = nrow(vote), ncol = n_chain)
l <- numeric(nrow(vote))
start_time <- Sys.time()
l <- sapply(1:nrow(vote), function(i) {
for (chain in 1:n_chain) {
prob[[chain]] <- vpProbability(vote, beta[chain,], alpha1[chain,],
alpha2[chain,], delta1[chain,], delta2[chain,])
product[chain,] <- (prob[[chain]][i,]^vote[i,]) * ((1 - prob[[chain]][i,])^(1 - vote[i,]))
summation[i, chain] <- sum(vote[i,] * log(prob[[chain]][i,])
+ (1 - vote[i,]) * (1 - log(prob[[chain]][i,])), na.rm = TRUE)
}
sum(log(colMeans(product, na.rm = TRUE)), na.rm = TRUE)
})
end_time <- Sys.time()
duration_old <- end_time - start_time
WAIC <- -2 * (sum(l) - sum(apply(summation, 1, var)))
n_chain = nrow(beta)
prob = list()
product = matrix(nrow = n_chain, ncol = ncol(vote))
summation = matrix(nrow = nrow(vote), ncol = n_chain)
l = numeric(nrow(vote))
start_time <- Sys.time()
for (i in 1 : nrow(vote)){
for (chain in 1 : n_chain){
prob[[chain]] = vpProbability(vote,beta[chain,],alpha1[chain,],
alpha2[chain,],delta1[chain,],delta2[chain,])
product[chain,] = (prob[[chain]][i,]^vote[i,])*((1-prob[[chain]][i,])^(1-vote[i,]))
summation[i,chain] = sum(vote[i,]*log(prob[[chain]][i,])
+(1-vote[i,])*(1-log(prob[[chain]][i,])), na.rm = TRUE)
}
l[i]=sum(log(colMeans(product, na.rm = TRUE)),na.rm = TRUE)
}
end_time <- Sys.time()
duration_old2 <- end_time - start_time
WAIC = -2*(sum(l)-sum(apply(summation,1,var)))
return(WAIC)
duration_old2
n_chain <- nrow(beta)
n_vote <- nrow(vote)
product <- matrix(nrow = n_vote, ncol = n_chain)
summation <- matrix(nrow = n_vote, ncol = n_chain)
l <- numeric(n_vote)
start_time <- Sys.time()
# Compute the probability and summation for each observation i
compute_prob_sum <- function(i) {
probs <- sapply(1:n_chain, function(chain) {
vpProbability(vote[i, , drop = FALSE], beta[chain, , drop = FALSE],
alpha1[chain, , drop = FALSE], alpha2[chain, , drop = FALSE],
delta1[chain, , drop = FALSE], delta2[chain, , drop = FALSE])
})
prod_probs <- apply(probs, 2, function(p) prod(p^vote[i, ] * (1 - p)^(1 - vote[i, ])))
sum_log_probs <- apply(probs, 2, function(p) sum(vote[i, ] * log(p) + (1 - vote[i, ]) * log(1 - p)))
product[i, ] <- prod_probs
summation[i, ] <- sum_log_probs
return(list(product = prod_probs, summation = sum_log_probs))
}
# Apply the function across all observations i
results <- lapply(1:n_vote, compute_prob_sum)
# Extract product and summation for the WAIC calculation
for (i in 1:n_vote) {
l[i] <- sum(log(results[[i]]$product))
summation[i, ] <- results[[i]]$summation
}
end_time <- Sys.time()
duration_new2 <- end_time - start_time
WAIC <- -2 * sum(l) - sum(apply(summation, 1, var))
n_chain = nrow(beta)
product = matrix(nrow = n_chain, ncol = ncol(vote))
summation = matrix(nrow = nrow(vote), ncol = n_chain)
l = numeric(nrow(vote))
start_time <- Sys.time()
for (i in 1:nrow(vote)) {
probs <- sapply(1:n_chain, function(chain) {
vpProbability(vote[i, , drop = FALSE], beta[chain, , drop = FALSE],
alpha1[chain, , drop = FALSE], alpha2[chain, , drop = FALSE],
delta1[chain, , drop = FALSE], delta2[chain, , drop = FALSE])
})
product[, i] <- apply(probs, 2, function(p) prod(p^vote[i, ] * (1 - p)^(1 - vote[i, ]), na.rm = TRUE))
summation[i, ] <- colSums(vote[i, ] * log(probs) + (1 - vote[i, ]) * log(1 - probs), na.rm = TRUE)
l[i] <- sum(log(colMeans(product, na.rm = TRUE)), na.rm = TRUE)
}
end_time <- Sys.time()
duration_new2 <- end_time - start_time
WAIC = -2 * ((sum(l) - sum(apply(summation, 1, var))))
n_chain <- nrow(beta)
n_vote <- nrow(vote)
product <- matrix(nrow = n_chain, ncol = n_vote)
summation <- matrix(nrow = n_vote, ncol = n_chain)
l <- numeric(n_vote)
start_time <- Sys.time()
for (i in 1:n_vote) {
# 对于每个i，计算所有链的概率
prob <- sapply(1:n_chain, function(chain) {
vpProbability(vote[i, , drop = FALSE], beta[chain, , drop = FALSE],
alpha1[chain, , drop = FALSE], alpha2[chain, , drop = FALSE],
delta1[chain, , drop = FALSE], delta2[chain, , drop = FALSE])
})
# 计算乘积和求和
product[, i] <- apply(prob, 2, function(p) prod(p^vote[i, ] * (1 - p)^(1 - vote[i, ]), na.rm = TRUE))
summation[i, ] <- sapply(1:n_chain, function(chain) sum(vote[i, ] * log(prob[,chain]) + (1 - vote[i, ]) * log(1 - prob[,chain]), na.rm = TRUE))
l[i] <- sum(log(rowMeans(product)))
}
end_time <- Sys.time()
duration_new2 <- end_time - start_time
WAIC <- -2 * (sum(l) - sum(apply(summation, 1, var)))
n_chain = nrow(beta)
prob = list()
product = matrix(nrow = n_chain, ncol = ncol(vote))
summation = matrix(nrow = nrow(vote), ncol = n_chain)
l = numeric(nrow(vote))
start_time <- Sys.time()
for (i in 1 : nrow(vote)){
for (chain in 1 : n_chain){
prob[[chain]] = vpProbability(vote,beta[chain,],alpha1[chain,],
alpha2[chain,],delta1[chain,],delta2[chain,])
product[chain,] = (prob[[chain]][i,]^vote[i,])*((1-prob[[chain]][i,])^(1-vote[i,]))
summation[i,chain] = sum(vote[i,]*log(prob[[chain]][i,])
+(1-vote[i,])*(1-log(prob[[chain]][i,])), na.rm = TRUE)
}
l[i]=sum(log(colMeans(product, na.rm = TRUE)),na.rm = TRUE)
}
end_time <- Sys.time()
duration_old2 <- end_time - start_time
WAIC = -2*(sum(l)-sum(apply(summation,1,var)))
# log-mean-exp trick function to prevent numerical underflow
logmeanexp <- function(x) {
m <- max(x)
m + log(mean(exp(x - m)))
}
n_chain <- nrow(beta)
lppd <- numeric(nrow(vote)) # log pointwise predictive density
p_var <- numeric(nrow(vote)) # variation of the log probabilities
start_time <- Sys.time()
for (i in 1:nrow(vote)) {
log_probs <- matrix(nrow = n_chain, ncol = ncol(vote))
for (chain in 1:n_chain) {
probs <- vpProbability(vote[i, , drop = FALSE], beta[chain, , drop = FALSE],
alpha1[chain, , drop = FALSE], alpha2[chain, , drop = FALSE],
delta1[chain, , drop = FALSE], delta2[chain, , drop = FALSE])
log_probs[chain, ] <- vote[i, ] * log(probs) + (1 - vote[i, ]) * log(1 - probs)
}
# Calculate the mean of the log probabilities for the ith observation
lppd[i] <- logmeanexp(log_probs) # Using log-sum-exp trick for numerical stability
# Calculate the variance of the log probabilities for the ith observation
p_var[i] <- apply(log_probs, 2, var)
}
end_time <- Sys.time()
duration_old2 <- end_time - start_time
WAIC <- -2 * (sum(lppd) - sum(p_var))
n_chain <- nrow(beta)
n_vote <- nrow(vote)
summation <- matrix(nrow = n_vote, ncol = n_chain)
l <- numeric(n_vote)
start_time <- Sys.time()
# Replace the inner loop with lapply
for (i in 1:n_vote) {
# Apply vpProbability to each chain
probs_list <- lapply(1:n_chain, function(chain) {
vpProbability(vote[i, , drop = FALSE], beta[chain, , drop = FALSE],
alpha1[chain, , drop = FALSE], alpha2[chain, , drop = FALSE],
delta1[chain, , drop = FALSE], delta2[chain, , drop = FALSE])
})
# Convert list of probabilities to matrix
probs_matrix <- do.call(cbind, probs_list)
# Compute product term
product <- apply(probs_matrix, 2, function(prob) {
prod(prob^vote[i, ] * (1 - prob)^(1 - vote[i, ]))
})
# Compute summation term
summation[i, ] <- colSums(log(probs_matrix) * vote[i, , drop = FALSE] +
log(1 - probs_matrix) * (1 - vote[i, , drop = FALSE]), na.rm = TRUE)
# Compute l term
l[i] <- sum(log(product), na.rm = TRUE)
}
vote = house_votes_m[1:20,]
n_chain = nrow(beta)
prob = list()
product = matrix(nrow = n_chain, ncol = ncol(vote))
summation = matrix(nrow = nrow(vote), ncol = n_chain)
l = numeric(nrow(vote))
start_time <- Sys.time()
for (i in 1 : nrow(vote)){
for (chain in 1 : n_chain){
prob[[chain]] = vpProbability(vote,beta[chain,],alpha1[chain,],
alpha2[chain,],delta1[chain,],delta2[chain,])
product[chain,] = (prob[[chain]][i,]^vote[i,])*((1-prob[[chain]][i,])^(1-vote[i,]))
summation[i,chain] = sum(vote[i,]*log(prob[[chain]][i,])
+(1-vote[i,])*(1-log(prob[[chain]][i,])), na.rm = TRUE)
}
l[i]=sum(log(colMeans(product, na.rm = TRUE)),na.rm = TRUE)
}
end_time <- Sys.time()
duration_old2 <- end_time - start_time
WAIC = -2*(sum(l)-sum(apply(summation,1,var)))
duration_old2
vote = house_votes_m[1:30,]
n_chain = nrow(beta)
prob = list()
product = matrix(nrow = n_chain, ncol = ncol(vote))
summation = matrix(nrow = nrow(vote), ncol = n_chain)
l = numeric(nrow(vote))
start_time <- Sys.time()
for (i in 1 : nrow(vote)){
for (chain in 1 : n_chain){
prob[[chain]] = vpProbability(vote,beta[chain,],alpha1[chain,],
alpha2[chain,],delta1[chain,],delta2[chain,])
product[chain,] = (prob[[chain]][i,]^vote[i,])*((1-prob[[chain]][i,])^(1-vote[i,]))
summation[i,chain] = sum(vote[i,]*log(prob[[chain]][i,])
+(1-vote[i,])*(1-log(prob[[chain]][i,])), na.rm = TRUE)
}
l[i]=sum(log(colMeans(product, na.rm = TRUE)),na.rm = TRUE)
}
end_time <- Sys.time()
duration_old2 <- end_time - start_time
WAIC = -2*(sum(l)-sum(apply(summation,1,var)))
duration_old2
document()
library(Voteprefer)
load("E:/OneDrive/UW_Seattle/paper/Abel/Voteprefer/data/house_votes_m.rda")
load("E:/OneDrive/UW_Seattle/paper/Abel/Voteprefer/data/param_draws.rda")
WAIC_old2 = vpWAIC_old2(vote = house_votes_m[1:10,],
beta = param_draws[1:10,1:429],
alpha1 = param_draws[1:10,430:1336],
alpha2 = param_draws[1:10,1337:2243],
delta1 = param_draws[1:10,2244:3150],
delta2 = param_draws[1:10,3151:4057])
document()
document()
library(Voteprefer)
WAIC = vpWAIC(vote = house_votes_m[1:10,],
beta = param_draws[1:10,1:429],
alpha1 = param_draws[1:10,430:1336],
alpha2 = param_draws[1:10,1337:2243],
delta1 = param_draws[1:10,2244:3150],
delta2 = param_draws[1:10,3151:4057])
vote = house_votes_m[1:10,]
beta = param_draws[1:10,1:429]
alpha1 = param_draws[1:10,430:1336]
alpha2 = param_draws[1:10,1337:2243]
delta1 = param_draws[1:10,2244:3150]
delta2 = param_draws[1:10,3151:4057]
n_chain = nrow(beta)
prob = list()
product = matrix(nrow = n_chain, ncol = ncol(vote))
summation = matrix(nrow = nrow(vote), ncol = n_chain)
l = numeric(nrow(vote))
for (i in 1 : nrow(vote)){
for (chain in 1 : n_chain){
prob[[chain]] = vpProbability(vote,beta[chain,],alpha1[chain,],
alpha2[chain,],delta1[chain,],delta2[chain,])
product[chain,] = (prob[[chain]][i,]^vote[i,])*((1-prob[[chain]][i,])^(1-vote[i,]))
summation[i,chain] = sum(vote[i,]*log(prob[[chain]][i,])
+(1-vote[i,])*(1-log(prob[[chain]][i,])), na.rm = TRUE)
}
l[i]=sum(log(colMeans(product, na.rm = TRUE)),na.rm = TRUE)
}
WAIC = -2*(sum(l)-sum(apply(summation,1,var)))
vpWAIC = function(vote,beta,alpha1,alpha2,delta1,delta2){
n_chain = nrow(beta)
prob = list()
product = matrix(nrow = n_chain, ncol = ncol(vote))
summation = matrix(nrow = nrow(vote), ncol = n_chain)
l = numeric(nrow(vote))
for (i in 1 : nrow(vote)){
for (chain in 1 : n_chain){
prob[[chain]] = vpProbability(vote,beta[chain,],alpha1[chain,],
alpha2[chain,],delta1[chain,],delta2[chain,])
product[chain,] = (prob[[chain]][i,]^vote[i,])*((1-prob[[chain]][i,])^(1-vote[i,]))
summation[i,chain] = sum(vote[i,]*log(prob[[chain]][i,])
+(1-vote[i,])*(1-log(prob[[chain]][i,])), na.rm = TRUE)
}
l[i]=sum(log(colMeans(product, na.rm = TRUE)),na.rm = TRUE)
}
WAIC = -2*(sum(l)-sum(apply(summation,1,var)))
return(WAIC)
}
WAIC = vpWAIC(vote = house_votes_m[1:10,],
beta = param_draws[1:10,1:429],
alpha1 = param_draws[1:10,430:1336],
alpha2 = param_draws[1:10,1337:2243],
delta1 = param_draws[1:10,2244:3150],
delta2 = param_draws[1:10,3151:4057])
View(vpWAIC)
rm(vpWAIC)
WAIC = vpWAIC(vote = house_votes_m[1:10,],
beta = param_draws[1:10,1:429],
alpha1 = param_draws[1:10,430:1336],
alpha2 = param_draws[1:10,1337:2243],
delta1 = param_draws[1:10,2244:3150],
delta2 = param_draws[1:10,3151:4057])
document()
library(Voteprefer)
load("E:/OneDrive/UW_Seattle/paper/Abel/Voteprefer/data/param_means.rda")
prob = vpProbability(vote = house_votes_m,
beta = param_means[1:429],
alpha1 = param_means[430:1336],
alpha2 = param_means[1337:2243],
delta1 = param_means[2244:3150],
delta2 = param_means[3151:4057])
WAIC = vpWAIC(vote = house_votes_m[1:10,],
beta = param_draws[1:10,1:429],
alpha1 = param_draws[1:10,430:1336],
alpha2 = param_draws[1:10,1337:2243],
delta1 = param_draws[1:10,2244:3150],
delta2 = param_draws[1:10,3151:4057])
document()
library(Voteprefer)
WAIC = vpWAIC(vote = house_votes_m[1:5,],
beta = param_draws[1:5,1:429],
alpha1 = param_draws[1:5,430:1336],
alpha2 = param_draws[1:5,1337:2243],
delta1 = param_draws[1:5,2244:3150],
delta2 = param_draws[1:5,3151:4057])
WAIC = vpWAIC(vote = house_votes_m[1:2,],
beta = param_draws[1:2,1:429],
alpha1 = param_draws[1:2,430:1336],
alpha2 = param_draws[1:2,1337:2243],
delta1 = param_draws[1:2,2244:3150],
delta2 = param_draws[1:2,3151:4057])
View(alpha1)
View(param_draws)
library(devtools)
document()
document()
document()
document()
